<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<style>
  /* --- Base & Typography --- */
  body {
    font-family: system-ui, Segoe UI, Inter, Arial, sans-serif;
    color: #0e1b2b;
    background-color: #f8fafc;
    margin: 0;
  }

  /* --- UI Components (Polished) --- */
  button {
    appearance: none;
    background-color: #ffffff;
    border: 1px solid #cbd5e1;
    border-radius: 6px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    color: #334155;
    cursor: pointer;
    font-family: system-ui, Segoe UI, Inter, Arial, sans-serif;
    font-size: 13px;
    font-weight: 500;
    padding: 6px 12px;
    transition: all 0.15s ease-in-out;
  }

  button:hover {
    background-color: #f1f5f9;
    border-color: #94a3b8;
    color: #0f172a;
  }

  button:active {
    background-color: #e2e8f0;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
  }

  select {
    appearance: none;
    background-color: #ffffff;
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
    background-position: right 0.5rem center;
    background-repeat: no-repeat;
    background-size: 1.5em 1.5em;
    border: 1px solid #cbd5e1;
    border-radius: 6px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    color: #334155;
    cursor: pointer;
    font-family: system-ui, Segoe UI, Inter, Arial, sans-serif;
    font-size: 13px;
    padding: 6px 2.5rem 6px 12px;
    transition: border-color 0.15s ease-in-out;
  }

  select:hover {
    border-color: #94a3b8;
  }

  select:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  /* --- Layout & Maps --- */
  #map, .multi-map {
    width: 960px;
    margin: 0 auto;
    position: relative;
  }

  #multi-view-container {
    display: flex;
    justify-content: space-around;
    width: 100%;
    margin-top: 20px;
  }

  .multi-map {
    width: 30%; 
    margin: 0;
  }

  /* --- Info Box --- */
  #infoBox {
    position: absolute;
    top: 20px;
    right: 30px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(4px);
    border: 1px solid rgba(0,0,0,0.08);
    border-radius: 12px;
    padding: 16px;
    font-family: system-ui, Segoe UI, Inter, Arial, sans-serif;
    font-size: 13px;
    line-height: 1.5;
    color: #334155;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    max-width: 300px;
    z-index: 100; 
  }

  #infoBox h4 {
    margin-top: 0;
    margin-bottom: 8px;
    color: #0f172a;
    font-size: 14px;
    font-weight: 600;
    border-bottom: 1px solid #e2e8f0;
    padding-bottom: 4px;
  }

  #infoBox b {
    color: #1e293b;
    font-weight: 600;
  }

  /* --- Controls --- */
  #timeline {
    position: absolute;
    top: 600px;
    left: 50%;
    transform: translateX(-50%);
  }

  #multiviewButton {
    position: absolute;
    top: 780px;
    left: 50%;
    transform: translateX(-50%);
    display: none; /* Maintained from original */
  }

  #dateDropdown {
    position: absolute;
    top: 630px;
    left: 50%;
    transform: translateX(-50%);
  }

  #prefixDropdown, #countryDropdown {
    position: absolute;
    left: 50%;
  }

  #prefixDropdown {
    top: 680px;
    transform: translateX(-50%);
  }

  #countryDropdown {
    top: 735px;
    transform: translateX(-50%);
  }

  .filter-label {
    position: absolute;
    font-family: system-ui, Segoe UI, Inter, Arial, sans-serif;
    font-size: 11px;
    font-weight: 700;
    color: #64748b;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    top: 658px;
  }

  #prefixLabel {
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    text-align: center;
    padding-left: 0;
  }

  #countryLabel {
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    text-align: center;
    padding-left: 0;
    top: 712px;
  }

  #autorotateButton, #playPauseButton {
    position: absolute;
    top: 700px;
    left: 50%;
    transform: translateX(-50%);
    display: none; /* Maintained from original */
  }

  #playPauseButton {
    top: 740px;
  }

  #xxx, #yyy {
    margin: 0 auto;
    position: relative;
  }
  #xxx {
    top: 800px;
  }
  #yyy {
    top: 820px;
  }

  /* --- Charts --- */
  .chart-title {
      font-family: system-ui, Segoe UI, Inter, Arial, sans-serif;
      font-weight: 600;
      fill: #334155;
  }
  
  .label {
      font-family: system-ui, Segoe UI, Inter, Arial, sans-serif;
      fill: #475569;
  }
  
  .count-label {
      font-family: system-ui, Segoe UI, Inter, Arial, sans-serif;
      font-weight: 500;
      fill: #64748b;
  }

  /* --- Legend --- */
  #legend {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(4px);
    border: 1px solid rgba(0,0,0,0.08);
    border-radius: 30px;
    padding: 10px 24px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    width: auto !important; /* Polish: Auto width centered */
    min-width: 400px;
    max-width: 90%;
  }
  
  #legend div {
      font-family: system-ui, Segoe UI, Inter, Arial, sans-serif;
  }

  /* --- Animations --- */
  .flightPath {
    pointer-events: none;
  }

  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
  }

  circle.pulsing {
    transform-origin: center center;
    animation: pulse 1s infinite;
  }

  @keyframes wave {
    0% { stroke-width: 1; fill: rgba(255, 215, 0, 0.3); }
    25% { stroke-width: 3; fill: rgba(255, 215, 0, 0.5); }
    50% { stroke-width: 5; fill: rgba(255, 215, 0, 0.7); }
    75% { stroke-width: 3; fill: rgba(255, 215, 0, 0.5); }
    100% { stroke-width: 1; fill: rgba(255, 215, 0, 0.3); }
  }

  path.country-wave {
    animation: wave 2s ease-in-out infinite;
  }
</style>

<div id="storyOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); color: white; display: flex; justify-content: center; align-items: center; z-index: 1000; flex-direction: column; text-align: center; font-family: sans-serif; font-size: 24px;">
  <div id="storyText"></div>
  <div id="storyCounter" style="font-size: 16px; margin-top: 20px;"></div>
</div>

<select id="dateDropdown">
  <option value="jan" selected>Before (Jan 2 2019)</option>
  <option value="apr">Peak (Apr 2 2020)</option>
  <option value="dec">After (Dec 2 2022)</option>
</select>

<button id="multiviewButton">Enter Multiview</button>
<button id="zoomInButton">Zoom In</button>
<button id="zoomOutButton">Zoom Out</button>
<button id="rotateUpButton">Rotate Up</button>
<button id="rotateDownButton">Rotate Down</button>
<button id="rotateLeftButton">Rotate Left</button>
<button id="rotateRightButton">Rotate Right</button>

<button id="jumpToAmerica">America</button>
<button id="jumpToCanada">Canada</button>
<button id="jumpToEurope">Europe</button>
<button id="jumpToAfrica">Africa</button>
<button id="jumpToAsia">Asia</button>
<button id="jumpToMiddleEast">Middle East</button>
<button id="jumpToSouthAmerica">South America</button>
<button id="jumpToAustralia" style="display:none">Australia</button>

<div id="infoBox">Click a plane or airport to see details</div>
<div id="single-view-container">
  <div id="map"></div>
</div>

<div id="multi-view-container" style="display: none;">
  <div id="map1" class="multi-map"></div>
  <div id="map2" class="multi-map"></div>
  <div id="map3" class="multi-map"></div>
</div>

<div id="legend" style="position: absolute; top: 700px; left: 50%; transform: translateX(-50%); text-align: center; font-family: sans-serif; width: 1000px;"></div>

<div id="timeline">
  <svg id="sliderSvg" width="960" height="60"></svg>
</div>

<label for="prefixDropdown" id="prefixLabel" class="filter-label">Airline</label>
<select id="prefixDropdown">
  <option value="">Select airline prefix</option>
</select>

<label for="countryDropdown" id="countryLabel" class="filter-label">Country</label>
<select id="countryDropdown">
  <option value="">Select country</option>
</select>


<button id="autorotateButton">Turn Autorotate On</button>
<button id="playPauseButton">Play Timeline</button>
<div id="globeCoordinatesLabel" style="position: absolute; top: 840px; left: 50%; transform: translateX(-50%); font-family: sans-serif; font-size: 13px; padding: 4px 6px; display: none;"></div>
<div id="xxx" style="display: none"></div>
<div id="yyy"></div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://d3js.org/topojson.v1.min.js"></script>

<script>
(async function () {
  // Storytelling setup
  const storyScreens = [
    { text: "The year is 2020. A new virus, COVID-19, begins to spread across the globe.", duration: 3000 },
    { text: "Borders close, flights are grounded, and the world watches as travel grinds to a halt.", duration: 3000 },
    { text: "This visualization explores the dramatic impact on global air traffic, comparing pre-pandemic, peak, and post-pandemic activity.", duration: 3000 }
  ];

  let currentStoryScreen = 0;
  let storyInterval;

  // Global dateInfo (moved from loadAllDatasets for broader access)
  const dateInfo = {
    'jan': { day1: 'flights100k-jan1.csv', day2: 'flights-jan-2nd-2019-filtered.csv', startTime: new Date("2019-01-02T00:00:00Z") },
    'apr': { day1: 'flights100k-apr1.csv', day2: 'flights-apr-2nd-2020-filtered.csv', startTime: new Date("2020-04-02T00:00:00Z") },
    'dec': { day1: 'flights100k-dec1.csv', day2: 'flights-dec-2nd-2022-filtered.csv', startTime: new Date("2022-12-02T00:00:00Z") }
  };

  // New story screens for the extended part
  const extendedStoryScreens = [
    { text: "Now, let's turn to Europe.", duration: 3000 },
    { text: "Here are flights flown by Airlines from the UK", duration: 3000}, // Mark this screen for the chart
  ];
  let currentExtendedStoryScreen = 0;
  let canadaFlightsDailyData = null; // To store the calculated data

  function beginStory() {
    d3.select("#storyOverlay").style("display", "flex");
    displayNextStoryScreen();

    // Hide dropdowns and labels
    d3.select("#prefixDropdown").style("display", "none");
    d3.select("#countryDropdown").style("display", "none");
    d3.select("#prefixLabel").style("display", "none");
    d3.select("#countryLabel").style("display", "none");
  }

  function displayNextStoryScreen() {
    if (currentStoryScreen < storyScreens.length) {
      const screen = storyScreens[currentStoryScreen];
      d3.select("#storyText").text(screen.text);
      let countdown = screen.duration / 1000;
      d3.select("#storyCounter").text(`Loading... Continuing soon...`);

      // check if csvs are loaded every second before moving on
      let checkInterval = setInterval(() => {
        if (allDatasets['jan'] && allDatasets['apr'] && allDatasets['dec']) {
          clearInterval(checkInterval);
          d3.select("#storyCounter").text(`Continuing in ${countdown} seconds...`);

          storyInterval = setInterval(() => {
            countdown--;
            d3.select("#storyCounter").text(`Continuing in ${countdown} seconds...`);
            if (countdown <= 0) {
              clearInterval(storyInterval);
              currentStoryScreen++;
              displayNextStoryScreen();
            }
          }, 1000);
        }
      }, 500);

      // storyInterval = setInterval(() => {
      //   countdown--;
      //   d3.select("#storyCounter").text(`Continuing soon...`);
      //   if (countdown <= 0) {
      //     clearInterval(storyInterval);
      //     currentStoryScreen++;
      //     displayNextStoryScreen();
      //   }
      // }, 3000);
    } else {
      // Story finished, keep overlay visible for the button
      d3.select("#storyOverlay").style("display", "none"); // Commented out

      // --- Post-story automation ---
      // 1. Rotate the globe to Canada
      rotateGlobeTo([-94.0667, 61.0942, 0]); // Existing Canada coordinates

      // 2. Select "Canada" in the country dropdown and trigger change event
      countryDropdown.property("value", "CANADA");
      countryDropdown.dispatch("change"); // Trigger the change event

      multiviewBtn.dispatch("click"); // Enter multiview mode
      // 3. Start playing the timeline
      playPauseBtn.dispatch("click"); // Simulate a click on the play/pause button

      // Wait until timeline is at 11:00pm
      const waitForTimelineAt2300 = setInterval(() => {
        const minutes = Math.round(xScale.invert(handle.attr("cx")));
        if (minutes >= 1380) { // 11:00 PM is 1380 minutes
          clearInterval(waitForTimelineAt2300);
          playPauseBtn.dispatch("click"); // Pause the timeline

          // Show continue story button
          // Add CSS for pulsing animation
          d3.select("head")
            .append("style")
            .html(`
              @keyframes pulse {
                0%   { transform: translateX(-50%) scale(1); }
                50%  { transform: translateX(-50%) scale(1.1); }
                100% { transform: translateX(-50%) scale(1); }
              }
              #continueStoryButton {
                animation: pulse 1.5s infinite ease-in-out;
              }
            `);

            d3.select("body").append("button")
              .attr("id", "continueStoryButton")
              .style("position", "absolute")
              .style("top", "740px")
              .style("left", "50%")
              .style("transform", "translateX(-50%)")
              .style("padding", "10px 20px")
              .style("font-size", "16px")
              .style("cursor", "pointer")
              .text("Continue Story");


          //d3.select("#continueStoryButton").style("display", "inline-block");
          // Attach event listener
          d3.select("#continueStoryButton").on("click", handleContinueStory);

          // Hide the legend
          d3.select("#legend").style("display", "none");
        }
      }, 500); // Check every half second

      

    }
  }

  function getCanadianFlightsDailyCounts() {
    const dailyCounts = {}; // { 'jan': {day1: count, day2: count}, 'apr': {...}, 'dec': {...} }

    for (const key in allDatasets) {
        const dataset = allDatasets[key];
        const flights = dataset.flights;
        
        const day1Flights = flights.filter(f => {
            const firstSeenDate = f.firstseen;
            if (!firstSeenDate) return false;
            const datasetStartDate = dateInfo[key].startTime;
            return firstSeenDate.getDate() === datasetStartDate.getDate() &&
                   firstSeenDate.getMonth() === datasetStartDate.getMonth() &&
                   firstSeenDate.getFullYear() === datasetStartDate.getFullYear();
        });

        const day2Flights = flights.filter(f => {
            const firstSeenDate = f.firstseen;
            if (!firstSeenDate) return false;
            const datasetStartDate = dateInfo[key].startTime;
            const nextDay = new Date(datasetStartDate);
            nextDay.setDate(datasetStartDate.getDate() + 1);
            return firstSeenDate.getDate() === nextDay.getDate() &&
                   firstSeenDate.getMonth() === nextDay.getMonth() &&
                   nextDay.getFullYear() === datasetStartDate.getFullYear(); // Corrected: use nextDay.getFullYear()
        });

        const canadianDay1Flights = day1Flights.filter(f => getCountryForFlight(f) === "CANADA").length;
        const canadianDay2Flights = day2Flights.filter(f => getCountryForFlight(f) === "CANADA").length;

        dailyCounts[key] = {
            day1: canadianDay1Flights,
            day2: canadianDay2Flights
        };
    }
    return dailyCounts;
  }

  function drawCanadaFlightsLineChart(data) {
    // data will be like: { 'jan': {day1: count, day2: count}, 'apr': {...}, 'dec': {...} }
    const chartContainer = d3.select("#storyOverlay").append("div")
        .attr("id", "canadaFlightsChart")
        .style("width", "80%")
        .style("height", "300px")
        .style("margin-top", "20px")
        .style("background-color", "white")
        .style("padding", "10px")
        .style("border-radius", "8px");

    const margin = {top: 20, right: 30, bottom: 30, left: 60},
          width = parseInt(chartContainer.style("width")) - margin.left - margin.right,
          height = parseInt(chartContainer.style("height")) - margin.top - margin.bottom;

    const svg = chartContainer.append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    const parseDate = d3.timeParse("%Y-%m-%d");
    const formatDay = d3.timeFormat("%b %d");

    // Prepare data for line chart
    const chartData = [];
    for (const key in data) {
        const info = dateInfo[key]; // Access dateInfo here
        const day1Date = info.startTime;
        const day2Date = new Date(info.startTime);
        day2Date.setDate(day2Date.getDate() + 1);

        chartData.push({
            date: day1Date,
            dataset: key,
            flights: data[key].day1
        });
        chartData.push({
            date: day2Date,
            dataset: key,
            flights: data[key].day2
        });
    }

    // Group data by dataset for lines
    const groupedData = d3.group(chartData, d => d.dataset);

    const x = d3.scaleTime()
        .domain(d3.extent(chartData, d => d.date))
        .range([0, width]);

    const y = d3.scaleLinear()
        .domain([0, d3.max(chartData, d => d.flights) * 1.1])
        .range([height, 0]);

    const color = d3.scaleOrdinal()
        .domain(Object.keys(data))
        .range(d3.schemeCategory10);

    // Add X axis
    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(x).tickFormat(formatDay));

    // Add Y axis
    svg.append("g")
        .call(d3.axisLeft(y));

    // Add the lines
    svg.selectAll(".line")
        .data(groupedData)
        .join("path")
        .attr("fill", "none")
        .attr("stroke", ([key]) => color(key))
        .attr("stroke-width", 1.5)
        .attr("d", ([, values]) => d3.line()
            .x(d => x(d.date))
            .y(d => y(d.flights))
            (values)
        );

    // Add dots
    svg.selectAll("dot")
        .data(chartData)
        .enter().append("circle")
        .attr("cx", d => x(d.date))
        .attr("cy", d => y(d.flights))
        .attr("r", 4)
        .attr("fill", d => color(d.dataset));

    // Add tooltips for dots
    const tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("position", "absolute")
        .style("background-color", "white")
        .style("border", "solid")
        .style("border-width", "1px")
        .style("border-radius", "5px")
        .style("padding", "10px")
        .style("visibility", "hidden");

    svg.selectAll("circle")
        .on("mouseover", function(event, d) {
            tooltip.style("visibility", "visible")
                .html(`Dataset: ${d.dataset}<br>Date: ${formatDay(d.date)}<br>Flights: ${d.flights}`);
        })
        .on("mousemove", function(event) {
            tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");
        })
        .on("mouseout", function() {
            tooltip.style("visibility", "hidden");
        });

    // Add legend
    const legend = svg.append("g")
        .attr("font-family", "sans-serif")
        .attr("font-size", 10)
        .attr("text-anchor", "end")
        .selectAll("g")
        .data(Object.keys(data).reverse())
        .enter().append("g")
        .attr("transform", (d, i) => `translate(0,${i * 20})`);

    legend.append("rect")
        .attr("x", width - 19)
        .attr("width", 19)
        .attr("height", 19)
        .attr("fill", color);

    legend.append("text")
        .attr("x", width - 24)
        .attr("y", 9.5)
        .attr("dy", "0.32em")
        .text(d => d);
  }

  function handleContinueStory() {
      d3.select("#continueStoryButton").remove(); // Remove the button
      d3.select("#storyOverlay").style("display", "flex"); // Ensure overlay is visible
      d3.select("#storyText").text(""); // Clear previous text
      d3.select("#storyCounter").text(""); // Clear previous counter

      if (!canadaFlightsDailyData) {
          canadaFlightsDailyData = getCanadianFlightsDailyCounts();
      }
      displayExtendedStoryScreen();
  }

  function displayExtendedStoryScreen() {
      if (currentExtendedStoryScreen < extendedStoryScreens.length) {
          const screen = extendedStoryScreens[currentExtendedStoryScreen];
          d3.select("#storyText").text(screen.text);
          d3.select("#canadaFlightsChart").remove(); // Remove previous chart if any

          // if (screen.chart === "canadaFlightsLineChart") {
          //     drawCanadaFlightsLineChart(canadaFlightsDailyData);
          // }

          let countdown = screen.duration / 1000;
          d3.select("#storyCounter").text(`Continuing in ${countdown} seconds...`);

          storyInterval = setInterval(() => {
              countdown--;
              d3.select("#storyCounter").text(`Continuing in ${countdown} seconds...`);
              if (countdown <= 0) {
                  clearInterval(storyInterval);
                  currentExtendedStoryScreen++;
                  displayExtendedStoryScreen();
              }
          }, 1000);
      } else {
          // All extended story screens finished
          d3.select("#storyOverlay").style("display", "none");
          d3.select("#legend").style("display", "block");
          //prefixDropdown.property("value", "FDX"); // Select Fedex
          //prefixDropdown.dispatch("change"); // Trigger change event
          countryDropdown.property("value", "UNITED KINGDOM");
          countryDropdown.dispatch("change"); // Trigger change event
          d3.select("#jumpToEurope").dispatch("click");
          d3.select("#zoomInButton").dispatch("click");
          d3.select("#zoomInButton").dispatch("click");

          // reset timeline to 00:00
          handle.attr("cx", xScale(0));
          updateAllGlobes(0);
          playPauseBtn.dispatch("click"); // Start playing the timeline again
          // wait until timeline is at 23:00 and then pause timeline again
          // also pop up a prompt to explore more
          const waitForTimelineAt2300Again = setInterval(() => {
            const minutes = Math.round(xScale.invert(handle.attr("cx")));
            if (minutes >= 1380) { // 11:00 PM is 1380 minutes
              clearInterval(waitForTimelineAt2300Again);
              playPauseBtn.dispatch("click"); // Pause the timeline
              
              d3.select("head")
              .append("style")
              .html(`
                @keyframes pulse {
                  0%   { transform: translateX(-50%) scale(1); }
                  50%  { transform: translateX(-50%) scale(1.1); }
                  100% { transform: translateX(-50%) scale(1); }
                }
                #continueStoryButton {
                  animation: pulse 1.5s infinite ease-in-out;
                }
              `);

              d3.select("body").append("button")
                .attr("id", "continueStoryButton")
                .style("position", "absolute")
                .style("top", "700px")
                .style("left", "50%")
                .style("transform", "translateX(-50%)")
                .style("padding", "10px 20px")
                .style("font-size", "16px")
                .style("cursor", "pointer")
                .text("Continue Story");
              d3.select("#legend").style("display", "none");


          //d3.select("#continueStoryButton").style("display", "inline-block");
          // Attach event listener
          d3.select("#continueStoryButton").on("click", () => {
              // Show dropdowns and labels
              d3.select("#legend").style("display", "block");
              d3.select("#legend").style("top", "790px");
              d3.select("#continueStoryButton").remove(); // Remove the button
              d3.select("#prefixDropdown").style("display", "block");
              d3.select("#countryDropdown").style("display", "block");
              d3.select("#prefixLabel").style("display", "block");
              d3.select("#countryLabel").style("display", "block");
           });

              
              //alert("Explore more by interacting with the globe and filters!");
            }
          }, 500); // Check every half second

  
          // d3.select("#canadaFlightsChart").remove(); // Ensure chart is removed
      }
  }

  // Call beginStory immediately
  beginStory();

  // Basic dimensions
  const width = 960; // Fixed width for main container
  const height = 500;
  const sensitivity = 70; // Increased sensitivity for more responsive dragging

  // NEW: Color scale for airlines
  const totalMinutes = 24 * 60;
  const stepMinutes = 5;

  const colorScale = d3.scaleOrdinal(d3.schemeCategory10.concat(d3.schemePaired));

  const world = await d3.json("world.json");
  const faaData = await d3.csv("faa.csv");
  const aircraftData = await d3.csv("aircraft.csv");
  const airportsData = await d3.csv("airports.csv");

  const faaLookup = {};
  faaData.forEach(d => {
    if(d['3Ltr']) faaLookup[d['3Ltr'].toUpperCase()] = d;
  });

  const aircraftLookup = {};
  aircraftData.forEach(d => {
    if(d.registration) aircraftLookup[d.registration.toUpperCase()] = d;
  });

  const airportLookup = {};
  airportsData.forEach(d => {
    [d.ident, d.icao_code, d.iata_code, d.gps_code].forEach(k => {
      if (k) {
        airportLookup[k.toUpperCase()] = d;
      }
    });
  });

  const largeAirports = airportsData.filter(d => d.type === "large_airport" && d.wikipedia_link);

  const countryCodeToName = {
    "RU": "Russia", "GH": "Ghana", "US": "United States of America", "GB": "United Kingdom",
    "FR": "France", "DE": "Germany", "IT": "Italy", "ES": "Spain", "JP": "Japan", "CN": "China",
    "IN": "India", "BR": "Brazil", "CA": "Canada", "AU": "Australia", "MX": "Mexico",
    "ID": "Indonesia", "TR": "Turkey", "SA": "Saudi Arabia", "EG": "Egypt", "NG": "Nigeria",
    "ZA": "South Africa", "AR": "Argentina", "CO": "Colombia", "PL": "Poland", "NL": "Netherlands",
    "BE": "Belgium", "SE": "Sweden", "NO": "Norway", "DK": "Denmark", "FI": "Finland",
    "CH": "Switzerland", "AT": "Austria", "PT": "Portugal", "GR": "Greece", "CZ": "Czechia",
    "HU": "Hungary", "RO": "Romania", "BG": "Bulgaria", "HR": "Croatia", "SI": "Slovenia",
    "SK": "Slovakia", "EE": "Estonia", "LV": "Latvia", "LT": "Lithuania", "UA": "Ukraine",
    "BY": "Belarus", "MD": "Moldova", "AL": "Albania", "ME": "Montenegro", "RS": "Serbia",
    "BA": "Bosnia and Herzegovina", "XK": "Kosovo", "MK": "North Macedonia", "IL": "Israel",
    "JO": "Jordan", "LB": "Lebanon", "SY": "Syria", "IQ": "Iraq", "IR": "Iran", "AF": "Afghanistan",
    "PK": "Pakistan", "BD": "Bangladesh", "LK": "Sri Lanka", "NP": "Nepal", "BT": "Bhutan",
    "MV": "Maldives", "MM": "Myanmar", "TH": "Thailand", "VN": "Vietnam", "LA": "Laos",
    "KH": "Cambodia", "KP": "North Korea", "KR": "South Korea", "MN": "Mongolia",
    "KZ": "Kazakhstan", "UZ": "Uzbekistan", "TM": "Turkmenistan", "TJ": "Tajikistan",
    "KG": "Kyrgyzstan", "AM": "Armenia", "AZ": "Azerbaijan", "GE": "Georgia", "CY": "Cyprus",
    "MA": "Morocco", "DZ": "Algeria", "TN": "Tunisia", "LY": "Libya", "SD": "Sudan",
    "SS": "South Sudan", "ET": "Ethiopia", "ER": "Eritrea", "DJ": "Djibouti", "SO": "Somalia",
    "KE": "Kenya", "TZ": "Tanzania", "UG": "Uganda", "RW": "Rwanda", "BI": "Burundi",
    "MR": "Mauritania", "ML": "Mali", "NE": "Niger", "TD": "Chad", "CF": "Central African Republic",
    "CM": "Cameroon", "GA": "Gabon", "CG": "Congo", "CD": "Democratic Republic of the Congo",
    "AO": "Angola", "ZM": "Zambia", "ZW": "Zimbabwe", "MZ": "Mozambique", "MG": "Madagascar",
    "MW": "Malawi", "LS": "Lesotho", "SZ": "Eswatini", "BW": "Botswana", "NA": "Namibia",
    "GM": "Gambia", "SL": "Sierra Leone", "LR": "Liberia", "CI": "Côte d'Ivoire", "TG": "Togo",
    "BJ": "Benin", "BF": "Burkina Faso", "GN": "Guinea", "GW": "Guinea-Bissau", "SN": "Senegal",
    "CV": "Cape Verde", "ST": "São Tomé and Príncipe", "GQ": "Equatorial Guinea"
  };

  // Global state for multiview
  let multiviewMode = false;
  let globeInstances = []; // Array to hold references to each globe's elements
  let allDatasets = {}; // Stores loaded data for 'jan', 'apr', 'dec'
  let currentDatasetKey = 'jan'; // Tracks active dataset in single view

  // Shared projection and path for synchronization
  let projection = d3.geoOrthographic()
    .scale(250)
    .center([0,0])
    .rotate([0, -30])
    .translate([width/2, height/2]);
  let path = d3.geoPath().projection(projection);
  const initialScale = projection.scale();

  // UI references
  const infoBox = d3.select("#infoBox");
  const dateDropdown = d3.select("#dateDropdown"); // Moved declaration here
  dateDropdown.on("change", function() {
    currentDatasetKey = this.value;
    // console.log("Date dropdown changed to:", currentDatasetKey);

    if (!multiviewMode) {
      // If in single view, remove the old globe and create a new one with the selected dataset
      globeInstances.forEach(g => g.svg.remove()); // Remove existing single globe
      globeInstances = []; // Clear the array
      globeInstances.push(createGlobe("#map", currentDatasetKey));
    }
    
    // Update all globes (including the newly created one if in single view)
    const minutes = Math.round(xScale.invert(handle.attr("cx")));
    updateAllGlobes(minutes);
  });
  const prefixDropdown = d3.select("#prefixDropdown"); // ADDED THIS LINE
  const countryDropdown = d3.select("#countryDropdown");
  const autorotateBtn = d3.select("#autorotateButton");
  const playPauseBtn = d3.select("#playPauseButton");
  const multiviewBtn = d3.select("#multiviewButton");

  // State
  let activeFlight = null;
  let activePrefixHighlight = null;
  let activeCountryHighlight = null;
  let activeAircraftHighlight = null;
  let activeAirport = null;
  let autorotate = false;
  let playing = false;
  let playTimer = null;

  const minAltitude = 0;
  const maxAltitude = 50000;
  const minScale = 1.0;
  const maxScale = 3.0;

  const altitudeScale = d3.scaleLinear()
  .domain([minAltitude, maxAltitude])
  .range([minScale, maxScale])
  .clamp(true);

  // Helper function to get country for a flight
  function getCountryForFlight(f) {
    const prefix = (f.callsign || "").slice(0, 3).toUpperCase();
    const airlineInfo = faaLookup[prefix];
    return (airlineInfo && airlineInfo.Country) ? airlineInfo.Country : null;
  }

  // Haversine distance function
  function haversineDistance(coords1, coords2) {
    const R = 6371; // Radius of the Earth in km
    const dLat = (coords2.lat - coords1.lat) * Math.PI / 180;
    const dLon = (coords2.lon - coords1.lon) * Math.PI / 180;
    const lat1 = coords1.lat * Math.PI / 180;
    const lat2 = coords1.lat * Math.PI / 180;

    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); 
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
    return R * c;
  }

  // Interpolate position
  function interpolatePosition(positions, time) {
    if (!positions || positions.length === 0) return null;
    if (positions.length === 1) return { lat: positions[0].lat, lon: positions[0].lon, altitude: positions[0].altitude };

    const timeMs = time.getTime();

    for (let i = 0; i < positions.length - 1; i++) {
      const p1 = positions[i];
      const p2 = positions[i+1];
      const t1 = p1.time.getTime();
      const t2 = p2.time.getTime();

      if (timeMs >= t1 && timeMs <= t2) {
        const ratio = (t2 - t1) > 0 ? (timeMs - t1) / (t2 - t1) : 0;
        const lat = p1.lat + (p2.lat - p1.lat) * ratio;
        const lon = p1.lon + (p2.lon - p1.lon) * ratio;
        const alt = (p1.altitude || 0) + ((p2.altitude || 0) - (p1.altitude || 0)) * ratio;
        return { lat, lon, altitude: alt };
      }
    }
    
    if (timeMs < positions[0].time.getTime()) return { lat: positions[0].lat, lon: positions[0].lon, altitude: positions[0].altitude };
    return { lat: positions[positions.length-1].lat, lon: positions[positions.length-1].lon, altitude: positions[positions.length-1].altitude };
  }

  // Pre-calculates all positions AND UI data for every 5-min interval on load
  function processFlightsData(rawFlights, datasetStartTime) {
    const icaoMap = new Map();
    rawFlights.forEach(f => {
      if (!f.icao24) return;
      if (!icaoMap.has(f.icao24)) {
        icaoMap.set(f.icao24, { ...f, positions: [] });
      }
      const flight = icaoMap.get(f.icao24);
      const time = f.firstseen ? new Date(f.firstseen) : (f.timestamp ? new Date(datasetStartTime.getTime() + f.timestamp * 1000) : null);
      if (time) {
        flight.positions.push({
          time: time,
          lat: +f.latitude_1,
          lon: +f.longitude_1,
          altitude: +f.altitude
        });
      }
    });

    // console.log("Pre-calculating positions...");
    icaoMap.forEach(flight => {
      flight.positions.sort((a, b) => a.time - b.time);
      if (flight.positions.length > 0) {
        flight.firstseen = flight.positions[0].time;
        flight.lastseen = flight.positions[flight.positions.length - 1].time;

        flight.precalculated = {};
        for (let minutes = 0; minutes <= totalMinutes; minutes += stepMinutes) {
            const currentTime = new Date(datasetStartTime.getTime() + minutes * 60000);
            if (currentTime >= flight.firstseen && currentTime <= flight.lastseen) {
                const pos = interpolatePosition(flight.positions, currentTime);
                if (pos) {
                    flight.precalculated[minutes] = pos;
                }
            }
        }
      }
    });
    // console.log("Pre-calculation complete.");

    const precalculatedUiData = new Map();
    for (let minutes = 0; minutes <= totalMinutes; minutes += stepMinutes) {
        const activeFlights = Array.from(icaoMap.values()).filter(f => f.precalculated && f.precalculated[minutes]);
        
        const prefixCounts = {};
        const countryIcaoSets = new Map();

        activeFlights.forEach(f => {
            const prefix = (f.callsign||"").slice(0,3).toUpperCase();
            if (!prefix) return;
            prefixCounts[prefix] = (prefixCounts[prefix] || 0) + 1;

            const airlineInfo = faaLookup[prefix];
            if (airlineInfo && airlineInfo.Country) {
              if (!countryIcaoSets.has(airlineInfo.Country)) {
                countryIcaoSets.set(airlineInfo.Country, new Set());
              }
              countryIcaoSets.get(airlineInfo.Country).add(f.icao24);
            }
        });

        const newTopPrefixes = Object.entries(prefixCounts)
            .sort((a,b)=>b[1]-a[1])
            .slice(0,20)
            .map(d=>d[0]);

        const countryCounts = new Map();
        countryIcaoSets.forEach((icaoSet, country) => {
          countryCounts.set(country, icaoSet.size);
        });

        const newTopCountries = Array.from(countryCounts.entries())
            .sort((a,b) => b[1] - a[1])
            .slice(0, 20)
            .map(d => d[0]);

        precalculatedUiData.set(minutes, { 
          topPrefixes: newTopPrefixes, 
          prefixCounts,
          topCountries: newTopCountries,
          countryCounts
        });
    }
    // console.log("UI pre-calculation complete.");

    return { flightsByIcao: icaoMap, flights: Array.from(icaoMap.values()), precalculatedUiData };
  }

  // Load all datasets at once
  async function loadAllDatasets() {
    // const dateInfo = { ... }; // REMOVED: now global

    for (const key in dateInfo) {
      const info = dateInfo[key];
      const rowConversion = d => ({
        ...d,
        firstseen: d.firstseen ? new Date(d.firstseen) : null,
        timestamp: d.timestamp && !isNaN(+d.timestamp) ? +d.timestamp : null,
        dest: d.destination ? d.destination.toUpperCase() : null,
      });

      const [rawFlights1, rawFlights2] = await Promise.all([
          d3.csv(info.day1, rowConversion),
          d3.csv(info.day2, rowConversion)
      ]);
      const combinedRawFlights = rawFlights1.concat(rawFlights2);
      allDatasets[key] = processFlightsData(combinedRawFlights, info.startTime);
    }
    // console.log("All datasets loaded.");
  }

  // Globe creation and management
  function createGlobe(containerSelector, datasetKey) {
    const container = d3.select(containerSelector);
    // Remove any existing SVG to prevent duplicates when re-creating globes in multiview
    container.select("svg").remove(); 

    const currentWidth = container.node().getBoundingClientRect().width;
    const currentHeight = multiviewMode ? 300 : height; 

    const svg = container.append("svg")
      .attr("width", currentWidth)
      .attr("height", currentHeight);

    // Add HTML label for multiview mode with high z-index
    container.selectAll(".globe-label").remove(); // Clear existing labels
    if (multiviewMode) {
      let labelText = '';
      let labelColor = '#334155'; // Default
      
      if (datasetKey === 'jan') {
        labelText = 'Before COVID';
        labelColor = '#2563eb';
      } else if (datasetKey === 'apr') {
        labelText = 'Peak COVID Lockdowns';
        labelColor = '#e24a4a';
      } else if (datasetKey === 'dec') {
        labelText = 'After COVID';
        labelColor = '#4ae24a';
      }

      container.append("div")
        .attr("class", "globe-label")
        .style("position", "absolute")
        .style("top", "10px")
        .style("right", "10px")
        .style("font-family", "system-ui, Segoe UI, Inter, Arial, sans-serif")
        .style("font-size", "14px")
        .style("font-weight", "700")
        .style("color", labelColor)
        .style("background", "rgba(255, 255, 255, 0.92)")
        .style("backdrop-filter", "blur(2px)")
        .style("padding", "6px 10px")
        .style("border-radius", "6px")
        .style("border", "1px solid rgba(0,0,0,0.05)")
        .style("box-shadow", "0 2px 4px rgba(0,0,0,0.1)")
        .style("z-index", "1000")
        .style("pointer-events", "none") // Let clicks pass through
        .text(labelText);
    }

    // Create a local projection for this globe instance
    const localProjection = d3.geoOrthographic()
      .scale(initialScale * (multiviewMode ? 0.4 : 1)) // Scale down for multiview
      .center([0,0])
      .rotate(projection.rotate()) // Initialize with the shared projection's rotation
      .translate([currentWidth/2, currentHeight/2]);
    
    const localPath = d3.geoPath().projection(localProjection);

    // Globe circle
    svg.append("circle")
      .attr("fill", "#EEE")
      .attr("stroke", "#000")
      .attr("stroke-width", 0.2)
      .attr("cx", currentWidth/2)
      .attr("cy", currentHeight/2)
      .attr("r", localProjection.scale()); 

    const mapGroup = svg.append("g");
    const countryPaths = mapGroup.append("g")
      .selectAll("path.country")
      .data(world.features)
      .enter()
      .append("path")
      .attr("class", "country")
      .attr("d", localPath)
      .attr("fill", "white")
      .style("stroke", "black")
      .style("stroke-width", 0.3)
      .style("opacity", 0.8);

    const pathsGroup = svg.append("g"); // Flight paths
    const allAirportsGroup = svg.append("g").attr("class", "all-airports"); // All airports
    const specialAirportsGroup = svg.append("g").attr("class", "special-airports"); // Special airports (selected)
    const pointsGroup = svg.append("g"); // Flight circles (should be on top)

    // Add all large airports
    allAirportsGroup.selectAll("rect.airport")
      .data(largeAirports)
      .enter().append("rect")
      .attr("class", "airport")
      .attr("width", 5)
      .attr("height", 5)
      .attr("fill", "blue")
      .attr("opacity", 0.3)
      .on("click", (event, d) => { 
        event.stopPropagation(); 
        showAirportInfo(d, datasetKey); 
      });

    function getActiveFlightsByTimeSlot(minutes) {
        const timeSlot = Math.round(minutes / stepMinutes) * stepMinutes;
        return allDatasets[datasetKey].flights.filter(f => f.precalculated && f.precalculated[timeSlot]);
    }

    function applyHighlightColors() {
      pointsGroup.selectAll("circle.flight")
        .attr("fill", d => {
          const prefix = (d.callsign||"").slice(0,3).toUpperCase();
          if (activeAircraftHighlight && (d.registration||"").toUpperCase() === activeAircraftHighlight) return "lime";
          if (activeFlight && d.icao24 === activeFlight.icao24) return "yellow";
          return colorScale(prefix);
        })
        .classed("pulsing", false);
    }

    function reprojectPaths() {
      pathsGroup.selectAll("path.flightPath")
        .attr("d", function(dPositions) {
          if (!Array.isArray(dPositions) || dPositions.length < 2) return null;
          const projected = dPositions
            .map(p => {
              const pr = localProjection([p.lon, p.lat]); // Use localProjection
              return pr ? [pr[0], pr[1]] : null;
            })
            .filter(p => p !== null);
          if (projected.length < 2) return null;
          return d3.line()(projected);
        });
    }

    function updateAllAirportPositions() {
      allAirportsGroup.selectAll("rect.airport")
        .attr("x", d => {
          const p = localProjection([+d.longitude_deg, +d.latitude_deg]); // Use localProjection
          return p ? p[0] - 2.5 : -100;
        })
        .attr("y", d => {
          const p = localProjection([+d.longitude_deg, +d.latitude_deg]); // Use localProjection
          return p ? p[1] - 2.5 : -100;
        });
    }

    function updateSpecialAirportPositions() {
      specialAirportsGroup.selectAll("rect.special-airport")
        .attr("x", d => {
          const p = localProjection([+d.ap.longitude_deg, +d.ap.latitude_deg]); // Use localProjection
          return p ? p[0] - 3 : -100;
        })
        .attr("y", d => {
          const p = localProjection([+d.ap.longitude_deg, +d.ap.latitude_deg]); // Use localProjection
          return p ? p[1] - 3 : -100;
        });

      specialAirportsGroup.selectAll("text.special-airport")
        .attr("x", d => {
          const p = localProjection([+d.ap.longitude_deg, +d.ap.latitude_deg]); // Use localProjection
          return p ? p[0] + 8 : -100;
        })
        .attr("y", d => {
          const p = localProjection([+d.ap.longitude_deg, +d.ap.latitude_deg]); // Use localProjection
          return p ? p[1] + 4 : -100;
        });
    }

    // This function will only update the positions of existing flight circles and airports
    function renderFlightsOnly(minutes) {
      const timeSlot = Math.round(minutes / stepMinutes) * stepMinutes;
      
      pointsGroup.selectAll("circle.flight")
        .each(function(d) {
          const pos = d.precalculated[timeSlot];
          if (pos) {
            const p = localProjection([pos.lon, pos.lat]); // Use localProjection
            d3.select(this)
              .attr("cx", p ? p[0] : -100)
              .attr("cy", p ? p[1] : -100)
              .attr("transform", `scale(${altitudeScale(pos.altitude || 0)})`);
          }
        });
      
    }

    // This function will handle data binding and full redraw
    function updateFlightsAndUI(minutes) {
      // console.log(`updateFlightsAndUI start: activePrefixHighlight=${activePrefixHighlight}, activeCountryHighlight=${activeCountryHighlight}`);
      const timeSlot = Math.round(minutes / stepMinutes) * stepMinutes; // Corrected typo here
      
      let activeFlights = getActiveFlightsByTimeSlot(minutes);

      if (activePrefixHighlight) {
        activeFlights = activeFlights.filter(f => (f.callsign || "").toUpperCase().startsWith(activePrefixHighlight));
      } else if (activeCountryHighlight) {
        activeFlights = activeFlights.filter(f => getCountryForFlight(f) === activeCountryHighlight);
      } else {
        const uiData = allDatasets[datasetKey].precalculatedUiData.get(timeSlot);
        const topPrefixesSet = new Set(uiData ? uiData.topPrefixes : []);
        activeFlights = activeFlights.filter(f => topPrefixesSet.has((f.callsign || "").slice(0, 3).toUpperCase()));
      }

      const circles = pointsGroup.selectAll("circle.flight")
        .data(activeFlights, d => d.icao24);

      circles.enter()
        .append("circle")
        .attr("class", "flight")
        .attr("r", 2.8)
        .attr("opacity", 0.85)
        .on("click", (event, d) => { event.stopPropagation(); selectFlight(d, datasetKey); })
        .merge(circles)
        .each(function(d) {
          const pos = d.precalculated[timeSlot];
          if (pos) {
            const p = localProjection([pos.lon, pos.lat]); // Use localProjection
            d3.select(this)
              .attr("cx", p ? p[0] : -100)
              .attr("cy", p ? p[1] : -100)
              .attr("transform", `scale(${altitudeScale(pos.altitude || 0)})`);
          }
        });

      circles.exit().remove();
      applyHighlightColors();
    }

    function clearSelection() {
      activeFlight = null;
      activeAirport = null;
      activeAircraftHighlight = null;
      pathsGroup.selectAll("path.flightPath").remove();
      specialAirportsGroup.selectAll("*").remove();
      applyHighlightColors();
    }

    // Drag rotation
    let currentRotation; // To store the current rotation during drag

    svg.call(d3.drag()
      .on("start", function(event) {
        currentRotation = projection.rotate(); // Get the current rotation at the start
      })
      .on("drag", function(event) {
        const k = sensitivity / projection.scale();
        currentRotation[0] += event.dx * k; // Increment longitude
        currentRotation[1] -= event.dy * k; // Decrement latitude (inverted)

        projection.rotate(currentRotation); // Apply the updated rotation
        updateAllGlobesProjection(true);
      })
      .on("end", function() {
        updateAllGlobesProjection(false);
      })
    );

    

    return {
      svg, mapGroup, countryPaths, pointsGroup, pathsGroup, specialAirportsGroup, allAirportsGroup,
      update: updateFlightsAndUI, 
      renderFlightsOnly, 
      clearSelection, applyHighlightColors, reprojectPaths, updateAllAirportPositions, updateSpecialAirportPositions,
      datasetKey,
      localProjection, // Expose local projection
      path: localPath // Expose local path
    };
  }

  // Function to update all globes' projections and optionally only render flights
  function updateAllGlobesProjection(renderOnlyFlights = false) {
    globeInstances.forEach(globe => {
      const container = d3.select(globe.svg.node().parentNode);
      const currentWidth = container.node().getBoundingClientRect().width;
      //const currentHeight = multiviewMode ? 300 : height;
      const currentHeight = height;
      
      globe.svg.attr("width", currentWidth)
               .attr("height", currentHeight);

      globe.localProjection
        .scale(projection.scale()) // Use the shared projection's current scale
        .rotate(projection.rotate()) // Sync rotation from shared projection
        .translate([currentWidth/2, currentHeight/2]);

      globe.svg.select("circle")
        .attr("cx", currentWidth/2)
        .attr("cy", currentHeight/2)
        .attr("r", globe.localProjection.scale());

      globe.countryPaths.attr("d", globe.path); // Use globe.path which uses localProjection
      globe.reprojectPaths();
      globe.updateAllAirportPositions();
      globe.updateSpecialAirportPositions();

      const minutes = Math.round(xScale.invert(handle.attr("cx")));
      if (renderOnlyFlights) {
        globe.renderFlightsOnly(minutes);
      } else {
        globe.update(minutes); // Call the full update (updateFlightsAndUI)
      }
    });

    // Update globe coordinates label
    const geographicCenter = projection.invert([width/2, height/2]);
    if (geographicCenter) { // Ensure geographicCenter is not null (can happen if projection is invalid)
      d3.select("#globeCoordinatesLabel").text(`Center: Lon ${geographicCenter[0].toFixed(2)}, Lat ${geographicCenter[1].toFixed(2)}`);
    } else {
      d3.select("#globeCoordinatesLabel").text(`Center: N/A`);
    }
  }

  // Main update function for all globes
  function updateAllGlobes(minutes) {
    const timeSlot = Math.round(minutes / stepMinutes) * stepMinutes;
    const uiData = allDatasets[currentDatasetKey].precalculatedUiData.get(timeSlot); // Use currentDatasetKey for UI data

    updatePrefixChart(uiData);
    updateCountryChart(uiData);
    updateLegend(uiData);

    globeInstances.forEach(globe => {
      globe.update(minutes);
    });
  }

  function updatePrefixChart(uiData) {
    const svg2 = d3.select("#xxx").select("svg");
    // svg2.selectAll("*").remove(); // Removed brute-force clear

    if (!uiData || !uiData.prefixCounts) {
      // Handle no data case by clearing existing elements and showing message
      svg2.selectAll("*").remove();
      svg2.attr("height", 50).append("text").attr("x", 10).attr("y", 20).attr("font-size", "12px").text("No flight data for this time.");
      return;
    };

    let topPrefixes;
    const prefixCounts = uiData.prefixCounts;

    if (activeCountryHighlight) {
        const countryPrefixes = Object.keys(faaLookup).filter(prefix => {
            return faaLookup[prefix].Country === activeCountryHighlight;
        });

        const prefixCountsInCountry = {};
        countryPrefixes.forEach(prefix => {
            if (prefixCounts[prefix]) {
                prefixCountsInCountry[prefix] = prefixCounts[prefix];
            }
        });

        topPrefixes = Object.keys(prefixCountsInCountry)
            .sort((a, b) => prefixCountsInCountry[b] - prefixCountsInCountry[a]);
    } else {
        topPrefixes = uiData.topPrefixes || [];
    }

    // Combine with always-include list and sort
    const allPrefixes = [...new Set([...alwaysIncludePrefixes, ...topPrefixes])].sort();

    // Update options for dropdown (already using update pattern)
    const options = prefixDropdown.selectAll("option.prefix").data(allPrefixes, d=>d);
    options.enter().append("option").attr("class","prefix").merge(options)
      .attr("value", d=>d)
      .text(d=> faaLookup[d] ? `${faaLookup[d].Company} (${d})` : d)
      .property("selected", d => d === activePrefixHighlight); // Set selected property
    options.exit().remove();

    // Add the currently active prefix highlight if it's not already in the options
    if (activePrefixHighlight && !topPrefixes.includes(activePrefixHighlight)) {
      prefixDropdown.append("option")
        .attr("class", "prefix")
        .attr("value", activePrefixHighlight)
        .text(faaLookup[activePrefixHighlight] ? `${faaLookup[activePrefixHighlight].Company} (${activePrefixHighlight})` : activePrefixHighlight)
        .property("selected", true); // Mark as selected
    }

    // Update chart title
    let chartTitle = svg2.select("text.chart-title");
    if (chartTitle.empty()) {
      chartTitle = svg2.append("text").attr("class", "chart-title").attr("x", 10).attr("y", 20).attr("font-size", "12px");
    }
    chartTitle.text("Top prefixes (live)");

    let maxLabelWidth = 0;
    // Temporarily append labels to measure width, then remove
    const tempLabels = svg2.append("g").attr("class", "temp-labels").style("opacity", 0).selectAll("text").data(topPrefixes).enter().append("text").attr("font-size", "11px").text(d => faaLookup[d] ? faaLookup[d].Company : d);
    tempLabels.each(function() { maxLabelWidth = Math.max(maxLabelWidth, this.getBBox().width); });
    tempLabels.remove();

    const barMargin = {top: 40, right: 30, bottom: 30, left: maxLabelWidth + 15};
    const barHeight = Math.max(100, topPrefixes.length * 18);
    svg2.attr("height", barMargin.top + barHeight + barMargin.bottom);
    const barWidth = width - barMargin.left - barMargin.right;
    
    if (barWidth < 50) return;

    const xScale = d3.scaleLinear().domain([0, d3.max(topPrefixes, d => prefixCounts[d]) || 1]).range([0, barWidth]);
    const yScale = d3.scaleBand().domain(topPrefixes).range([0, barHeight]).padding(0.1);
    
    let barGroup = svg2.select("g.bar-group");
    if (barGroup.empty()) {
      barGroup = svg2.append("g").attr("class", "bar-group");
    }
    barGroup.attr("transform", `translate(${barMargin.left},${barMargin.top})`);

    // Update bars
    const bars = barGroup.selectAll("rect")
      .data(topPrefixes, d => d);

    bars.enter().append("rect")
      .attr("y", d => yScale(d))
      .attr("height", yScale.bandwidth())
      .attr("fill", d => colorScale(d))
      .merge(bars)
      .transition().duration(200) // Add a small transition for smoothness
      .attr("width", d => xScale(prefixCounts[d] || 0));

    bars.exit().remove();

    // Update labels
    const labels = barGroup.selectAll("text.label")
      .data(topPrefixes, d => d);

    labels.enter().append("text")
      .attr("class", "label")
      .attr("x", -5)
      .attr("text-anchor", "end")
      .attr("font-size", "11px")
      .merge(labels)
      .transition().duration(200)
      .attr("y", d => yScale(d) + yScale.bandwidth() / 2 + 4)
      .text(d => faaLookup[d] ? faaLookup[d].Company : d);

    labels.exit().remove();

    // Update count labels
    const countLabels = barGroup.selectAll("text.count-label")
      .data(topPrefixes, d => d);

    countLabels.enter().append("text")
      .attr("class", "count-label")
      .attr("font-size", "11px")
      .merge(countLabels)
      .transition().duration(200)
      .attr("x", d => xScale(prefixCounts[d] || 0) + 5)
      .attr("y", d => yScale(d) + yScale.bandwidth() / 2 + 4)
      .text(d => prefixCounts[d] || 0);

    countLabels.exit().remove();

    // Update axis
    let xAxisGroup = barGroup.select("g.x-axis");
    if (xAxisGroup.empty()) {
      xAxisGroup = barGroup.append("g").attr("class", "x-axis");
    }
    xAxisGroup.attr("transform", `translate(0,${barHeight})`).call(d3.axisBottom(xScale).ticks(4));
  }

  function updateCountryChart(uiData) {
    const svg3 = d3.select("#yyy").select("svg");
    // svg3.selectAll("*").remove(); // Removed brute-force clear

    if (!uiData || !uiData.topCountries || uiData.topCountries.length === 0) {
      // Handle no data case by clearing existing elements and showing message
      svg3.selectAll("*").remove();
      svg3.attr("height", 50).append("text").attr("x", 10).attr("y", 20).attr("font-size", "12px").text("No country data for this time.");
      return;
    }

    const topCountries = uiData.topCountries;
    const countryCounts = uiData.countryCounts;

    // Update options for dropdown (already using update pattern)
    const options = countryDropdown.selectAll("option.country").data(topCountries, d => d);
    options.enter().append("option").attr("class", "country").merge(options)
      .attr("value", d => d)
      .text(d => d)
      .property("selected", d => d === activeCountryHighlight); // Set selected property
    options.exit().remove();

    // Add the currently active country highlight if it's not already in the options
    if (activeCountryHighlight && !topCountries.includes(activeCountryHighlight)) {
      countryDropdown.append("option")
        .attr("class", "country")
        .attr("value", activeCountryHighlight)
        .text(activeCountryHighlight)
        .property("selected", true); // Mark as selected
    }

    // Update chart title
    let chartTitle = svg3.select("text.chart-title");
    if (chartTitle.empty()) {
      chartTitle = svg3.append("text").attr("class", "chart-title").attr("x", 10).attr("y", 20).attr("font-size", "12px");
    }
    chartTitle.text("Top Countries by flights (live)");

    let maxLabelWidth = 0;
    const tempLabels = svg3.append("g").attr("class", "temp-labels").style("opacity", 0).selectAll("text").data(topCountries).enter().append("text").attr("font-size", "11px").text(d => d);
    tempLabels.each(function() { maxLabelWidth = Math.max(maxLabelWidth, this.getBBox().width); });
    tempLabels.remove();

    const barMargin = {top: 40, right: 30, bottom: 30, left: maxLabelWidth + 15};
    const barHeight = Math.max(100, topCountries.length * 18);
    svg3.attr("height", barMargin.top + barHeight + barMargin.bottom);
    const barWidth = width - barMargin.left - barMargin.right;

    if (barWidth < 50) return;

    const xScale = d3.scaleLinear().domain([0, d3.max(topCountries, d => countryCounts.get(d)) || 1]).range([0, barWidth]);
    const yScale = d3.scaleBand().domain(topCountries).range([0, barHeight]).padding(0.1);
    
    let barGroup = svg3.select("g.bar-group");
    if (barGroup.empty()) {
      barGroup = svg3.append("g").attr("class", "bar-group");
    }
    barGroup.attr("transform", `translate(${barMargin.left},${barMargin.top})`);

    // Update bars
    const bars = barGroup.selectAll("rect")
      .data(topCountries, d => d);

    bars.enter().append("rect")
      .attr("y", d => yScale(d))
      .attr("height", yScale.bandwidth())
      .attr("fill", d => colorScale(d))
      .merge(bars)
      .transition().duration(200)
      .attr("width", d => xScale(countryCounts.get(d) || 0));

    bars.exit().remove();

    // Update labels
    const labels = barGroup.selectAll("text.label")
      .data(topCountries, d => d);

    labels.enter().append("text")
      .attr("class", "label")
      .attr("x", -5)
      .attr("text-anchor", "end")
      .attr("font-size", "11px")
      .merge(labels)
      .transition().duration(200)
      .attr("y", d => yScale(d) + yScale.bandwidth() / 2 + 4)
      .text(d => d);

    labels.exit().remove();

    // Update count labels
    const countLabels = barGroup.selectAll("text.count-label")
      .data(topCountries, d => d);

    countLabels.enter().append("text")
      .attr("class", "count-label")
      .attr("font-size", "11px")
      .merge(countLabels)
      .transition().duration(200)
      .attr("x", d => xScale(countryCounts.get(d) || 0) + 5)
      .attr("y", d => yScale(d) + yScale.bandwidth() / 2 + 4)
      .text(d => countryCounts.get(d) || 0);

    countLabels.exit().remove();

    // Update axis
    let xAxisGroup = barGroup.select("g.x-axis");
    if (xAxisGroup.empty()) {
      xAxisGroup = barGroup.append("g").attr("class", "x-axis");
    }
    xAxisGroup.attr("transform", `translate(0,${barHeight})`).call(d3.axisBottom(xScale).ticks(4));
  }

  function updateLegend(uiData) {
    const legendContainer = d3.select("#legend");
    legendContainer.html(""); // Clear previous legend

    if (!uiData || !uiData.prefixCounts) {
        return;
    }

    let topPrefixes;
    let legendTitleText = "Top Airlines";

    if (activePrefixHighlight) {
        topPrefixes = [activePrefixHighlight];
        const airlineName = faaLookup[activePrefixHighlight] ? faaLookup[activePrefixHighlight].Company : activePrefixHighlight;
        legendTitleText = `Selected Airline: ${airlineName}`;
    } else if (activeCountryHighlight) {
        const countryPrefixes = Object.keys(faaLookup).filter(prefix => {
            return faaLookup[prefix].Country === activeCountryHighlight;
        });

        const prefixCountsInCountry = {};
        countryPrefixes.forEach(prefix => {
            if (uiData.prefixCounts[prefix]) {
                prefixCountsInCountry[prefix] = uiData.prefixCounts[prefix];
            }
        });

        topPrefixes = Object.keys(prefixCountsInCountry)
            .sort((a, b) => prefixCountsInCountry[b] - prefixCountsInCountry[a]);
        
        topPrefixes = topPrefixes.slice(0, 10); // Limit to 10
        legendTitleText = `Top Airlines in ${activeCountryHighlight}`;
    } else {
        topPrefixes = (uiData.topPrefixes || []).slice(0, 10); // Limit to 10
    }

    const legendTitle = legendContainer.append("div")
        .style("font-weight", "bold")
        .style("margin-bottom", "5px")
        .text(legendTitleText);

    const legendItems = legendContainer.selectAll(".legend-item")
        .data(topPrefixes)
        .enter()
        .append("div")
        .attr("class", "legend-item")
        .style("display", "inline-flex")
        .style("align-items", "center")
        .style("margin-right", "15px")
        .style("margin-bottom", "5px");

    legendItems.append("svg")
        .attr("width", 12)
        .attr("height", 12)
        .style("flex-shrink", "0")
        .append("circle")
        .attr("cx", 6)
        .attr("cy", 6)
        .attr("r", 6)
        .style("fill", d => colorScale(d));

    legendItems.append("span")
        .style("font-size", "12px")
        .style("margin-left", "5px")
        .text(d => faaLookup[d] ? faaLookup[d].Company : d);

    // Add Airport Legend Item
    const airportLegendItem = legendContainer.append("div")
        .attr("class", "legend-item")
        .style("display", "inline-flex")
        .style("align-items", "center")
        .style("margin-right", "15px")
        .style("margin-bottom", "5px")
        .style("border-left", "1px solid #cbd5e1")
        .style("padding-left", "15px");

    airportLegendItem.append("svg")
        .attr("width", 12)
        .attr("height", 12)
        .style("flex-shrink", "0")
        .append("rect")
        .attr("width", 8)
        .attr("height", 8)
        .attr("x", 2)
        .attr("y", 2)
        .style("fill", "blue")
        .style("opacity", 0.5);

    airportLegendItem.append("span")
        .style("font-size", "12px")
        .style("margin-left", "5px")
        .text("Major Airport");
  }

  function animateCountry(countryName) {
    globeInstances.forEach(globe => {
      globe.countryPaths.classed("country-wave", false);
      if (!countryName) return;
      globe.countryPaths
        .filter(function(d) { return d.properties.name === countryName; })
        .classed("country-wave", true);
    });
  }

  function clearCountryAnimation() {
    globeInstances.forEach(globe => {
      globe.countryPaths.classed("country-wave", false);
    });
  }

  function selectFlight(f, datasetKey) {
    activeFlight = f;
    activeAirport = null;
    activeAircraftHighlight = (f.registration||"").toUpperCase();
    clearCountryAnimation();
    
    globeInstances.forEach(globe => globe.applyHighlightColors());
    
    // Clear paths on all globes, then draw on the one where the flight was selected
    globeInstances.forEach(globe => globe.pathsGroup.selectAll("path.flightPath").remove());

    const currentGlobe = globeInstances.find(g => g.datasetKey === datasetKey);
    if (!currentGlobe) return;

    const flightPositions = f.positions;

    if (flightPositions.length > 1) {
      const projectedPoints = flightPositions
        .map(p => {
          const pr = currentGlobe.localProjection([p.lon, p.lat]); // Use currentGlobe's localProjection
          return pr ? [pr[0], pr[1]] : null;
        })
        .filter(pp => pp);

      if (projectedPoints.length > 1) {
        const pathElement = currentGlobe.pathsGroup.append("path")
          .datum(flightPositions)
          .attr("class", "flightPath")
          .attr("fill", "none")
          .attr("stroke", "orange")
          .attr("stroke-width", 1.8)
          .attr("opacity", 0.95)
          .attr("stroke-linecap", "round")
          .attr("stroke-linejoin", "round");

        const initialD = d3.line()(projectedPoints);
        pathElement.attr("d", initialD);

        try {
          const totalLength = pathElement.node().getTotalLength();
          pathElement
            .attr("stroke-dasharray", totalLength + " " + totalLength)
            .attr("stroke-dashoffset", totalLength)
            .transition()
            .duration(1500)
            .ease(d3.easeLinear)
            .attr("stroke-dashoffset", 0);
        } catch (e) {}
      }
    }

    const prefix = (f.callsign||"").slice(0,3).toUpperCase();
    const airline = faaLookup[prefix];
    const aircraft = aircraftLookup[(f.registration||"").toUpperCase()];
    const origAirport = airportLookup[(f.origin || "").toUpperCase()];
    const destAirport = airportLookup[(f.dest || "").toUpperCase()];

    let page = 0;
    const pageSize = 5;
    const totalPages = Math.ceil(flightPositions.length / pageSize);

    function renderPage() {
      const start = page * pageSize;
      const end = Math.min(start + pageSize, flightPositions.length);
      const subset = flightPositions.slice(start, end);

      let tableHTML = `
        <table style="font-size:12px; border-collapse: collapse; margin-top:6px;">
          <tr><th align="left">Time (UTC)</th><th align="left">Latitude</th><th align="left">Longitude</th></tr>
          ${subset.map(p => {
            const time = p.time.toISOString().substring(11,19);
            return `<tr><td>${time}</td><td>${p.lat.toFixed(2)}</td><td>${p.lon.toFixed(2)}</td></tr>`;
          }).join("")}
        </table>
        <div style="margin-top:6px; text-align:center;">
          <button id="prevPageBtn" ${page===0?'disabled':''}>Prev</button>
          Page ${page+1} of ${totalPages}
          <button id="nextPageBtn" ${page>=totalPages-1?'disabled':''}>Next</button>
        </div>
      `;

      let originDetails = '';
      if (origAirport) {
        originDetails = `
          <h4>Airport Info - Origin</h4>
          <b>Name:</b> ${origAirport.name}<br>
          <b>Ident:</b> ${origAirport.ident || "N/A"}<br>
          <b>Location:</b> ${origAirport.latitude_deg}, ${origAirport.longitude_deg}<br>
          <b>Elevation:</b> ${origAirport.elevation_ft || "N/A"} ft<br>
          <b>Country:</b> ${origAirport.iso_country || "N/A"}<br>
        `;
      }

      let destDetails = '';
      if (destAirport) {
        destDetails = `
          <h4>Airport Info - Destination</h4>
          <b>Name:</b> ${destAirport.name}<br>
          <b>Ident:</b> ${destAirport.ident || "N/A"}<br>
          <b>Location:</b> ${destAirport.latitude_deg}, ${destAirport.longitude_deg}<br>
          <b>Elevation:</b> ${destAirport.elevation_ft || "N/A"} ft<br>
          <b>Country:</b> ${destAirport.iso_country || "N/A"}<br>
        `;
      }

      infoBox.html(`
        <strong>Flight Info</strong><br>
        <b>ICAO24:</b> ${f.icao24 || "N/A"}<br>
        <b>Registration:</b> ${f.registration || "N/A"}<br>
        <b>Model:</b> ${aircraft ? aircraft.model : "N/A"}<br>
        <b>From:</b> ${f.origin || "N/A"} <b>→ To:</b> ${f.dest || "N/A"}<br>
        <b>Callsign:</b> ${f.callsign || "N/A"}<br>
        <b>Airline:</b> ${airline ? airline.Company : "N/A"}<br>
        ${originDetails}
        ${destDetails}
        <br><b>Positions:</b> (${flightPositions.length} total)
        ${tableHTML}
      `);

      d3.select("#prevPageBtn").on("click", () => { if (page > 0) { page--; renderPage(); } });
      d3.select("#nextPageBtn").on("click", () => { if (page < totalPages-1) { page++; renderPage(); } });
    }

    renderPage();

    const airportPoints = [];
    if (origAirport) airportPoints.push({ap: origAirport, color: "green", label: "Origin: " + origAirport.name});
    if (destAirport) airportPoints.push({ap: destAirport, color: "red", label: "Dest: " + destAirport.name});

    globeInstances.forEach(globe => {
      const apRects = globe.specialAirportsGroup.selectAll("rect.special-airport").data(airportPoints);
      apRects.enter().append("rect").attr("class", "special-airport")
        .merge(apRects)
        .attr("width", 6).attr("height", 6).attr("fill", d => d.color).attr("opacity", 0.8);
      apRects.exit().remove();

      const apLabels = globe.specialAirportsGroup.selectAll("text.special-airport").data(airportPoints);
      apLabels.enter().append("text").attr("class", "special-airport")
        .merge(apLabels)
        .attr("font-size", "12px")
        .attr("fill", "black")
        .text(d => d.label.slice(0,20));
      apLabels.exit().remove();

      globe.updateSpecialAirportPositions();
    });
  }

  function showAirportInfo(ap, datasetKey) {
    activeFlight = null;
    //activePrefixHighlight = null;
   // activeCountryHighlight = null;
    activeAircraftHighlight = null;
    activeAirport = ap;
    
    globeInstances.forEach(globe => {
      globe.pathsGroup.selectAll("path.flightPath").remove();
      globe.specialAirportsGroup.selectAll("*").remove();
      globe.applyHighlightColors();
    });

    const airportCountryName = Object.entries(countryCodeToName).find(([code, name]) => code === ap.iso_country)?.[1] || ap.iso_country;
    animateCountry(airportCountryName);

    // --- STATS CALCULATION ---
    const minutes = Math.round(xScale.invert(handle.attr("cx")));
    const timeSlot = Math.round(minutes / stepMinutes) * stepMinutes;
    
    const currentDataset = allDatasets[datasetKey];
    const activeFlights = currentDataset.flights.filter(f => f.precalculated && f.precalculated[timeSlot]);

    // Country Stats
    const faaCountryName = Object.values(faaLookup).find(val => val.Country.toUpperCase().includes(airportCountryName.toUpperCase()))?.Country || "N/A";
    const airlinesInCountry = Object.values(faaLookup).filter(val => val.Country === faaCountryName).length;
    const activeFlightsInCountry = activeFlights.filter(f => getCountryForFlight(f) === faaCountryName).length;

    // Airport Stats
    const airportIdent = ap.ident.toUpperCase();
    let originCount = 0;
    let destCount = 0;
    currentDataset.flights.forEach(f => {
      if ((f.origin || "").toUpperCase() === airportIdent) originCount++;
      if ((f.dest || "").toUpperCase() === airportIdent) destCount++;
    });

    // Radar Stats
    const radarDistances = [50, 100, 250]; // in km
    const radarCounts = radarDistances.map(d => 0);
    const airportCoords = { lat: +ap.latitude_deg, lon: +ap.longitude_deg };

    activeFlights.forEach(f => {
      const pos = f.precalculated[timeSlot];
      if (pos) {
        const dist = haversineDistance(airportCoords, pos);
        for (let i = 0; i < radarDistances.length; i++) {
          if (dist <= radarDistances[i]) {
            radarCounts[i]++;
          }
        }
      }
    });
    
    let countryStatsHtml = `
      <h4>Country Stats (${faaCountryName})</h4>
      <b>Airlines Registered:</b> ${airlinesInCountry}<br>
      <b>Active Flights Now:</b> ${activeFlightsInCountry}<br>
    `;

    let airportStatsHtml = `
      <h4>Airport Stats (All Day)</h4>
      <b>Flights with this Origin:</b> ${originCount}<br>
      <b>Flights with this Destination:</b> ${destCount}<br>
    `;

    let radarStatsHtml = `
      <h4>Nearby Flights (Live Radar)</h4>
      ${radarDistances.map((d, i) => `<b>&lt; ${d}km:</b> ${radarCounts[i]} flights<br>`).join("")}
    `;

    let details = `
      <h4>Airport Info</h4>
      <b>Name:</b> ${ap.name}<br>
      <b>Ident:</b> ${ap.ident || "N/A"}<br>
      <b>Location:</b> ${ap.latitude_deg}, ${ap.longitude_deg}<br>
      <b>Elevation:</b> ${ap.elevation_ft || "N/A"} ft<br>
      <b>Country:</b> ${ap.iso_country || "N/A"}<br>
    `;
    if (ap.wikipedia_link) details += `<a href="${ap.wikipedia_link}" target="_blank">Wikipedia</a><br>`;

    infoBox.html(`
      ${details}
      ${countryStatsHtml}
      ${airportStatsHtml}
      ${radarStatsHtml}
    `);

    const point = [{ap: ap, color: "purple", label: ap.name.slice(0,20)}];
    globeInstances.forEach(globe => {
      const apRects = globe.specialAirportsGroup.selectAll("rect.special-airport").data(point);
      apRects.enter().append("rect").attr("class", "special-airport")
        .merge(apRects)
        .attr("width", 6).attr("height", 6).attr("fill", d => d.color).attr("opacity", 0.8);

      const apLabels = globe.specialAirportsGroup.selectAll("text.special-airport").data(point);
      apLabels.enter().append("text").attr("class", "special-airport")
        .merge(apLabels)
        .attr("font-size", "12px")
        .attr("fill", "black")
        .text(d => d.label.slice(0,20));
      apLabels.exit().remove();

      globe.updateSpecialAirportPositions();
    });
  }

  // Timeline Slider
  const sliderWidth = 900;
  const sliderHeight = 50;
  const margin = {left:30, right:30};
  const xScale = d3.scaleLinear().domain([0, totalMinutes]).range([margin.left, sliderWidth - margin.right]);
  const svgSlider = d3.select("#sliderSvg");

  svgSlider.append("line")
    .attr("x1", xScale(0))
    .attr("x2", xScale(totalMinutes))
    .attr("y1", sliderHeight/2)
    .attr("y2", sliderHeight/2)
    .attr("stroke", "#aaa")
    .attr("stroke-width", 4);

  const handle = svgSlider.append("circle")
    .attr("cx", xScale(0))
    .attr("cy", sliderHeight/2)
    .attr("r", 8)
    .attr("fill", "steelblue")
    .call(d3.drag()
      .on("start", () => { if (playing) playPauseBtn.dispatch("click"); })
      .on("drag", (event) => {
        let x = event.x;
        x = Math.max(xScale(0), Math.min(xScale(totalMinutes), x));
        const minutes = Math.round(xScale.invert(x)/stepMinutes)*stepMinutes;
        const newX = xScale(minutes);
        handle.attr("cx", newX);

        const hours = Math.floor(minutes/60);
        const mins = minutes % 60;
        updateAllGlobes(minutes);
        d3.select("#timeLabel").text(`Time: ${String(hours).padStart(2,"0")}:${String(mins).padStart(2,"0")} UTC`);
      })
    );

  const xAxis = d3.axisBottom(xScale)
    .tickValues(d3.range(0, totalMinutes+1, 60))
    .tickFormat(d => `${String(Math.floor(d/60)).padStart(2,"0")}:00`);

  svgSlider.append("g")
    .attr("transform", `translate(0, ${sliderHeight/2 + 15})`)
    .call(xAxis)
    .selectAll("text")
    .style("font-size", "12px");

  prefixDropdown.on("change", function(){
    activePrefixHighlight = this.value || null;
    activeCountryHighlight = null;
    activeFlight = null;
    activeAircraftHighlight = null;
    // console.log(`Prefix changed: activePrefixHighlight=${activePrefixHighlight}, activeCountryHighlight=${activeCountryHighlight}`);
    
    globeInstances.forEach(globe => globe.pathsGroup.selectAll("path.flightPath").remove());
    
    const minutes = Math.round(xScale.invert(handle.attr("cx")));
    updateAllGlobes(minutes);
    
    infoBox.text(activePrefixHighlight ? `Showing flights for: ${activePrefixHighlight}` : "Showing top airlines/countries. Click a plane or airport for details.");
  });

  countryDropdown.on("change", function(){
    //alert("changed");
    activeCountryHighlight = this.value || null;
    activePrefixHighlight = null;
    activeFlight = null;
    activeAircraftHighlight = null;
    // console.log(`Country changed: activePrefixHighlight=${activePrefixHighlight}, activeCountryHighlight=${activeCountryHighlight}`);
    
    globeInstances.forEach(globe => globe.pathsGroup.selectAll("path.flightPath").remove());
    
    const minutes = Math.round(xScale.invert(handle.attr("cx")));
    updateAllGlobes(minutes);
    
    infoBox.text(activeCountryHighlight ? `Showing flights for: ${activeCountryHighlight}` : "Showing top airlines/countries. Click a plane or airport for details.");
  });

  autorotateBtn.on("click", ()=>{
    autorotate = !autorotate;
    autorotateBtn.text(autorotate ? "Turn Autorotate Off" : "Turn Autorotate On");
  });

  playPauseBtn.on("click", ()=>{
    playing = !playing;
    playPauseBtn.text(playing ? "Pause Timeline" : "Play Timeline");
    if (playing) {
      if (playTimer) clearInterval(playTimer);
      playTimer = setInterval(()=>{
        const cx = +handle.attr("cx");
        let currentMinutes = Math.round(xScale.invert(cx));
        let nextMinutes = currentMinutes + stepMinutes;
        if (nextMinutes > totalMinutes) nextMinutes = 0;
        
        const newX = xScale(nextMinutes);
        handle.transition().duration(48).ease(d3.easeLinear).attr("cx", newX); // Adjust animation duration

        const hours = Math.floor(nextMinutes/60);
        const mins = nextMinutes % 60;
        const countryFilterBefore = activeCountryHighlight;
        //alert(countryFilterBefore);
        updateAllGlobes(nextMinutes);
        if (activeCountryHighlight !== countryFilterBefore) {
          countryDropdown.property("value", activeCountryHighlight || "");
        }
        d3.select("#timeLabel").text(`Time: ${String(hours).padStart(2,"0")}:${String(mins).padStart(2,"0")} UTC`);
      }, 50); // Increased interval duration
    } else {
      clearInterval(playTimer);
      handle.transition();
      const minutes = Math.round(xScale.invert(handle.attr("cx")));
      const countryFilterBefore = activeCountryHighlight;
      updateAllGlobes(minutes);
      if (activeCountryHighlight !== countryFilterBefore) {
        countryDropdown.property("value", activeCountryHighlight || "");
      }
    }
  });

  d3.select("#xxx").append("text").attr("id","timeLabel").text("Time: 00:00 UTC");

  // Background click clears selection
  d3.select("body").on("click", () => { // Changed to body to catch clicks outside globes
    activeFlight = null;
    activeAirport = null;
    activeAircraftHighlight = null;
    //activePrefixHighlight = null;
    //activeCountryHighlight = null;
    globeInstances.forEach(g => g.clearSelection());
    infoBox.text("Showing top airlines/countries. Click a plane or airport for details.");
  });

  // Multiview button logic
  multiviewBtn.on("click", ()=>{
    multiviewMode = !multiviewMode;
    multiviewBtn.text(multiviewMode ? "Exit Multiview" : "Enter Multiview");

    d3.select("#single-view-container").style("display", multiviewMode ? "none" : "block");
    d3.select("#multi-view-container").style("display", multiviewMode ? "flex" : "none");

    // Hide date dropdown in multiview, as each map represents a date
    d3.select("#dateDropdown").style("display", multiviewMode ? "none" : "block");

    // Hide the infoBox in multiview mode to prevent overlap
    d3.select("#infoBox").style("display", multiviewMode ? "none" : "block");

    // Clear existing globes and re-create them based on multiviewMode
    globeInstances.forEach(g => g.svg.remove()); // Remove all existing SVGs
    globeInstances = []; // Clear the array

    if (multiviewMode) {
      globeInstances.push(createGlobe("#map1", 'jan'));
      globeInstances.push(createGlobe("#map2", 'apr'));
      globeInstances.push(createGlobe("#map3", 'dec'));
    } else {
      globeInstances.push(createGlobe("#map", currentDatasetKey));
    }
    
    updateAllGlobesProjection();
    updateAllGlobes(Math.round(xScale.invert(handle.attr("cx"))));
  });

  // Zoom buttons
  d3.select("#zoomInButton").on("click", () => {
    const currentScale = projection.scale();
    projection.scale(currentScale * 1.2); // Zoom in by 20%
    updateAllGlobesProjection();
  });

  d3.select("#zoomOutButton").on("click", () => {
    const currentScale = projection.scale();
    projection.scale(currentScale / 1.2); // Zoom out by 20%
    updateAllGlobesProjection();
  });

  // Directional rotation buttons
  const rotationStep = 5; // degrees

  d3.select("#rotateUpButton").on("click", () => {
    const r = projection.rotate();
    projection.rotate([r[0], r[1] + rotationStep, r[2]]);
    updateAllGlobesProjection();
  });

  d3.select("#rotateDownButton").on("click", () => {
    const r = projection.rotate();
    projection.rotate([r[0], r[1] - rotationStep, r[2]]);
    updateAllGlobesProjection();
  });

  d3.select("#rotateLeftButton").on("click", () => {
    const r = projection.rotate();
    projection.rotate([r[0] - rotationStep, r[1], r[2]]);
    updateAllGlobesProjection();
  });

  d3.select("#rotateRightButton").on("click", () => {
    const r = projection.rotate();
    projection.rotate([r[0] + rotationStep, r[1], r[2]]);
    updateAllGlobesProjection();
  });

  // Helper function for smooth globe rotation
  function rotateGlobeTo(targetGeographicCoordinates) { // Renamed for clarity
    const targetLon = targetGeographicCoordinates[0];
    const targetLat = targetGeographicCoordinates[1];
    const targetRoll = targetGeographicCoordinates[2] || 0; // Default to 0 if not provided

    // Invert longitude and latitude to get the correct rotation for centering
    const actualTargetRotation = [-targetLon, -targetLat, targetRoll];

    d3.transition()
      .duration(750) // milliseconds for the transition
      .tween("rotate", function() {
        const r = d3.interpolate(projection.rotate(), actualTargetRotation);
        return function(t) {
          projection.rotate(r(t));
          updateAllGlobesProjection(); // Update all globes during transition
        };
      });
  }

  // Location jump buttons
  d3.select("#jumpToAmerica").on("click", () => {
    rotateGlobeTo([-98.5795, 39.8283, 0]); // More precise coordinates for continental US center
  });
  d3.select("#jumpToCanada").on("click", () => {
    rotateGlobeTo([-94.0667, 61.0942, 0]); // More precise coordinates for Canada center
  });
  d3.select("#jumpToEurope").on("click", () => {
    rotateGlobeTo([2.3522, 48.8566, 0]); // Paris coordinates
  });
  d3.select("#jumpToAfrica").on("click", () => {
    rotateGlobeTo([21.7587, -2.0000, 0]); // More precise coordinates for Africa center
  });
  d3.select("#jumpToAsia").on("click", () => {
    rotateGlobeTo([103.8272, 36.0594, 0]); // More precise coordinates for China center (Asia)
  });
  d3.select("#jumpToMiddleEast").on("click", () => {
    rotateGlobeTo([45, 25, 0]); // Geographical center for Middle East
  });
  d3.select("#jumpToSouthAmerica").on("click", () => {
    rotateGlobeTo([-56.0979, -15.5959, 0]); // More precise coordinates for Brazil center (South America)
  });
  d3.select("#jumpToAustralia").on("click", () => {
    rotateGlobeTo([133.8807, -23.6980, 0]); // More precise coordinates for Australia center
  });

  // Initial Load
  await loadAllDatasets();

  // Calculate Top 40 prefixes from Jan 2nd data
  const janFlights = allDatasets['jan'].flights;
  const prefixCountsJan2 = {};
  janFlights.forEach(f => {
      const prefix = (f.callsign || "").slice(0, 3).toUpperCase();
      if (prefix) {
          prefixCountsJan2[prefix] = (prefixCountsJan2[prefix] || 0) + 1;
      }
  });

  const top40prefixes = Object.entries(prefixCountsJan2)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 40)
      .map(d => d[0]);

  // Find Air Canada prefix
  const airCanadaPrefix = faaData.find(d => d.Company === 'Air Canada')?.['3Ltr']?.toUpperCase() || 'ACA';

  // Define the list of prefixes to always include in the dropdown.
  const alwaysIncludePrefixes = [...new Set(['FDX', 'UPS', airCanadaPrefix, ...top40prefixes])];

  globeInstances.push(createGlobe("#map", currentDatasetKey));
  updateAllGlobes(0);
})();
</script>
</html>